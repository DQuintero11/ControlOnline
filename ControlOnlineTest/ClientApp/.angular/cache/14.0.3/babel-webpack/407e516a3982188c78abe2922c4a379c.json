{"ast":null,"code":"import _defineProperty from \"C:/Users/danie/source/repos/ControlOnlineTest/ControlOnlineTest/ClientApp/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as i0 from '@angular/core';\nimport { inject, PLATFORM_ID, Injectable, NgModule, VERSION } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common'; // Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\n\nlet hasV8BreakIterator; // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\n\ntry {\n  hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;\n} catch {\n  hasV8BreakIterator = false;\n}\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\n\n\nclass Platform {\n  // We want to use the Angular platform check because if the Document is shimmed\n  // without the navigator, the following checks will fail. This is preferred because\n  // sometimes the Document may be shimmed without the user's knowledge or intention\n\n  /** Whether the Angular application is being rendered in the browser. */\n\n  /** Whether the current browser is Microsoft Edge. */\n\n  /** Whether the current rendering engine is Microsoft Trident. */\n  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n\n  /** Whether the current rendering engine is Blink. */\n  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n  // ensure that Webkit runs standalone and is not used as another engine's base.\n\n  /** Whether the current rendering engine is WebKit. */\n\n  /** Whether the current platform is Apple iOS. */\n  // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n  // them self as Gecko-like browsers and modify the userAgent's according to that.\n  // Since we only cover one explicit Firefox case, we can simply check for Firefox\n  // instead of having an unstable check for Gecko.\n\n  /** Whether the current browser is Firefox. */\n\n  /** Whether the current platform is Android. */\n  // Trident on mobile adds the android platform to the userAgent to trick detections.\n  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n  // Safari browser should also use Webkit as its layout engine.\n\n  /** Whether the current browser is Safari. */\n  constructor() {\n    _defineProperty(this, \"_platformId\", inject(PLATFORM_ID));\n\n    _defineProperty(this, \"isBrowser\", this._platformId ? isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document);\n\n    _defineProperty(this, \"EDGE\", this.isBrowser && /(edge)/i.test(navigator.userAgent));\n\n    _defineProperty(this, \"TRIDENT\", this.isBrowser && /(msie|trident)/i.test(navigator.userAgent));\n\n    _defineProperty(this, \"BLINK\", this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n\n    _defineProperty(this, \"WEBKIT\", this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT);\n\n    _defineProperty(this, \"IOS\", this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window));\n\n    _defineProperty(this, \"FIREFOX\", this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent));\n\n    _defineProperty(this, \"ANDROID\", this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT);\n\n    _defineProperty(this, \"SAFARI\", this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT);\n  }\n\n}\n\n_defineProperty(Platform, \"\\u0275fac\", function Platform_Factory(t) {\n  return new (t || Platform)();\n});\n\n_defineProperty(Platform, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Platform,\n  factory: Platform.ɵfac,\n  providedIn: 'root'\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Platform, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\nclass PlatformModule {}\n\n_defineProperty(PlatformModule, \"\\u0275fac\", function PlatformModule_Factory(t) {\n  return new (t || PlatformModule)();\n});\n\n_defineProperty(PlatformModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: PlatformModule\n}));\n\n_defineProperty(PlatformModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n/** Cached result Set of input types support by the current browser. */\n\n\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\n\nconst candidateInputTypes = [// `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n// first changing it to something else:\n// The specified value \"\" does not conform to the required format.\n// The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n'color', 'button', 'checkbox', 'date', 'datetime-local', 'email', 'file', 'hidden', 'image', 'month', 'number', 'password', 'radio', 'range', 'reset', 'search', 'submit', 'tel', 'text', 'time', 'url', 'week'];\n/** @returns The input types supported by this browser. */\n\nfunction getSupportedInputTypes() {\n  // Result is cached.\n  if (supportedInputTypes) {\n    return supportedInputTypes;\n  } // We can't check if an input type is not supported until we're on the browser, so say that\n  // everything is supported when not on the browser. We don't use `Platform` here since it's\n  // just a helper function and can't inject it.\n\n\n  if (typeof document !== 'object' || !document) {\n    supportedInputTypes = new Set(candidateInputTypes);\n    return supportedInputTypes;\n  }\n\n  let featureTestInput = document.createElement('input');\n  supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n    featureTestInput.setAttribute('type', value);\n    return featureTestInput.type === value;\n  }));\n  return supportedInputTypes;\n}\n/** Cached result of whether the user's browser supports passive event listeners. */\n\n\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\n\nfunction supportsPassiveEventListeners() {\n  if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n    try {\n      window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n        get: () => supportsPassiveEvents = true\n      }));\n    } finally {\n      supportsPassiveEvents = supportsPassiveEvents || false;\n    }\n  }\n\n  return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\n\n\nfunction normalizePassiveListenerOptions(options) {\n  return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n/** The possible ways the browser may handle the horizontal scroll axis in RTL languages. */\n\n\nvar RtlScrollAxisType;\n\n(function (RtlScrollAxisType) {\n  /**\n   * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\n   * all the way right.\n   */\n  RtlScrollAxisType[RtlScrollAxisType[\"NORMAL\"] = 0] = \"NORMAL\";\n  /**\n   * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n   * all the way right.\n   */\n\n  RtlScrollAxisType[RtlScrollAxisType[\"NEGATED\"] = 1] = \"NEGATED\";\n  /**\n   * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n   * all the way right.\n   */\n\n  RtlScrollAxisType[RtlScrollAxisType[\"INVERTED\"] = 2] = \"INVERTED\";\n})(RtlScrollAxisType || (RtlScrollAxisType = {}));\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\n\n\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\n\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\n\nfunction supportsScrollBehavior() {\n  if (scrollBehaviorSupported == null) {\n    // If we're not in the browser, it can't be supported. Also check for `Element`, because\n    // some projects stub out the global `document` during SSR which can throw us off.\n    if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n      scrollBehaviorSupported = false;\n      return scrollBehaviorSupported;\n    } // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n\n\n    if ('scrollBehavior' in document.documentElement.style) {\n      scrollBehaviorSupported = true;\n    } else {\n      // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n      // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n      const scrollToFunction = Element.prototype.scrollTo;\n\n      if (scrollToFunction) {\n        // We can detect if the function has been polyfilled by calling `toString` on it. Native\n        // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n        // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n        // polyfilled functions as supporting scroll behavior.\n        scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n      } else {\n        scrollBehaviorSupported = false;\n      }\n    }\n  }\n\n  return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\n\n\nfunction getRtlScrollAxisType() {\n  // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n  if (typeof document !== 'object' || !document) {\n    return RtlScrollAxisType.NORMAL;\n  }\n\n  if (rtlScrollAxisType == null) {\n    // Create a 1px wide scrolling container and a 2px wide content element.\n    const scrollContainer = document.createElement('div');\n    const containerStyle = scrollContainer.style;\n    scrollContainer.dir = 'rtl';\n    containerStyle.width = '1px';\n    containerStyle.overflow = 'auto';\n    containerStyle.visibility = 'hidden';\n    containerStyle.pointerEvents = 'none';\n    containerStyle.position = 'absolute';\n    const content = document.createElement('div');\n    const contentStyle = content.style;\n    contentStyle.width = '2px';\n    contentStyle.height = '1px';\n    scrollContainer.appendChild(content);\n    document.body.appendChild(scrollContainer);\n    rtlScrollAxisType = RtlScrollAxisType.NORMAL; // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n    // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n    // dealing with one of the other two types of browsers.\n\n    if (scrollContainer.scrollLeft === 0) {\n      // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n      // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n      // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n      // return 0 when we read it again.\n      scrollContainer.scrollLeft = 1;\n      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;\n    }\n\n    scrollContainer.remove();\n  }\n\n  return rtlScrollAxisType;\n}\n\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\n\nfunction _supportsShadowDom() {\n  if (shadowDomIsSupported == null) {\n    const head = typeof document !== 'undefined' ? document.head : null;\n    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n  }\n\n  return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\n\n\nfunction _getShadowRoot(element) {\n  if (_supportsShadowDom()) {\n    const rootNode = element.getRootNode ? element.getRootNode() : null; // Note that this should be caught by `_supportsShadowDom`, but some\n    // teams have been able to hit this code path on unsupported browsers.\n\n    if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n      return rootNode;\n    }\n  }\n\n  return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\n\n\nfunction _getFocusedElementPierceShadowDom() {\n  let activeElement = typeof document !== 'undefined' && document ? document.activeElement : null;\n\n  while (activeElement && activeElement.shadowRoot) {\n    const newActiveElement = activeElement.shadowRoot.activeElement;\n\n    if (newActiveElement === activeElement) {\n      break;\n    } else {\n      activeElement = newActiveElement;\n    }\n  }\n\n  return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\n\n\nfunction _getEventTarget(event) {\n  // If an event is bound outside the Shadow DOM, the `event.target` will\n  // point to the shadow root so we have to use `composedPath` instead.\n  return event.composedPath ? event.composedPath()[0] : event.target;\n}\n/** Gets whether the code is currently running in a test environment. */\n\n\nfunction _isTestEnvironment() {\n  // We can't use `declare const` because it causes conflicts inside Google with the real typings\n  // for these symbols and we can't read them off the global object, because they don't appear to\n  // be attached there for some runners like Jest.\n  // (see: https://github.com/angular/components/issues/23365#issuecomment-938146643)\n  return (// @ts-ignore\n    typeof __karma__ !== 'undefined' && !!__karma__ || // @ts-ignore\n    typeof jasmine !== 'undefined' && !!jasmine || // @ts-ignore\n    typeof jest !== 'undefined' && !!jest || // @ts-ignore\n    typeof Mocha !== 'undefined' && !!Mocha\n  );\n} // TODO(crisbeto): remove this function when making breaking changes for v20.\n\n/**\n * Binds an event listener with specific options in a backwards-compatible way.\n * This function is necessary, because `Renderer2.listen` only supports listener options\n * after 19.1 and during the v19 period we support any 19.x version.\n * @docs-private\n */\n\n\nfunction _bindEventWithOptions(renderer, target, eventName, callback, options) {\n  const major = parseInt(VERSION.major);\n  const minor = parseInt(VERSION.minor); // Event options in `listen` are only supported in 19.1 and beyond.\n  // We also allow 0.0.x, because that indicates a build at HEAD.\n\n  if (major > 19 || major === 19 && minor > 0 || major === 0 && minor === 0) {\n    return renderer.listen(target, eventName, callback, options);\n  }\n\n  target.addEventListener(eventName, callback, options);\n  return () => {\n    target.removeEventListener(eventName, callback, options);\n  };\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Platform, PlatformModule, RtlScrollAxisType, _bindEventWithOptions, _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _isTestEnvironment, _supportsShadowDom, getRtlScrollAxisType, getSupportedInputTypes, normalizePassiveListenerOptions, supportsPassiveEventListeners, supportsScrollBehavior };","map":{"version":3,"names":["i0","inject","PLATFORM_ID","Injectable","NgModule","VERSION","isPlatformBrowser","hasV8BreakIterator","Intl","v8BreakIterator","Platform","constructor","_platformId","document","isBrowser","test","navigator","userAgent","window","chrome","CSS","EDGE","TRIDENT","BLINK","WEBKIT","type","args","providedIn","PlatformModule","supportedInputTypes","candidateInputTypes","getSupportedInputTypes","Set","featureTestInput","createElement","filter","value","setAttribute","supportsPassiveEvents","supportsPassiveEventListeners","addEventListener","Object","defineProperty","get","normalizePassiveListenerOptions","options","capture","RtlScrollAxisType","rtlScrollAxisType","scrollBehaviorSupported","supportsScrollBehavior","Element","documentElement","style","scrollToFunction","prototype","scrollTo","toString","getRtlScrollAxisType","NORMAL","scrollContainer","containerStyle","dir","width","overflow","visibility","pointerEvents","position","content","contentStyle","height","appendChild","body","scrollLeft","NEGATED","INVERTED","remove","shadowDomIsSupported","_supportsShadowDom","head","createShadowRoot","attachShadow","_getShadowRoot","element","rootNode","getRootNode","ShadowRoot","_getFocusedElementPierceShadowDom","activeElement","shadowRoot","newActiveElement","_getEventTarget","event","composedPath","target","_isTestEnvironment","__karma__","jasmine","jest","Mocha","_bindEventWithOptions","renderer","eventName","callback","major","parseInt","minor","listen","removeEventListener"],"sources":["C:/Users/danie/source/repos/ControlOnlineTest/ControlOnlineTest/ClientApp/node_modules/@angular/cdk/fesm2022/platform.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { inject, PLATFORM_ID, Injectable, NgModule, VERSION } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;\n}\ncatch {\n    hasV8BreakIterator = false;\n}\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nclass Platform {\n    _platformId = inject(PLATFORM_ID);\n    // We want to use the Angular platform check because if the Document is shimmed\n    // without the navigator, the following checks will fail. This is preferred because\n    // sometimes the Document may be shimmed without the user's knowledge or intention\n    /** Whether the Angular application is being rendered in the browser. */\n    isBrowser = this._platformId\n        ? isPlatformBrowser(this._platformId)\n        : typeof document === 'object' && !!document;\n    /** Whether the current browser is Microsoft Edge. */\n    EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n    /** Whether the current rendering engine is Microsoft Trident. */\n    TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n    // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n    /** Whether the current rendering engine is Blink. */\n    BLINK = this.isBrowser &&\n        !!(window.chrome || hasV8BreakIterator) &&\n        typeof CSS !== 'undefined' &&\n        !this.EDGE &&\n        !this.TRIDENT;\n    // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n    // ensure that Webkit runs standalone and is not used as another engine's base.\n    /** Whether the current rendering engine is WebKit. */\n    WEBKIT = this.isBrowser &&\n        /AppleWebKit/i.test(navigator.userAgent) &&\n        !this.BLINK &&\n        !this.EDGE &&\n        !this.TRIDENT;\n    /** Whether the current platform is Apple iOS. */\n    IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n    // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n    // them self as Gecko-like browsers and modify the userAgent's according to that.\n    // Since we only cover one explicit Firefox case, we can simply check for Firefox\n    // instead of having an unstable check for Gecko.\n    /** Whether the current browser is Firefox. */\n    FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n    /** Whether the current platform is Android. */\n    // Trident on mobile adds the android platform to the userAgent to trick detections.\n    ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n    // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n    // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n    // Safari browser should also use Webkit as its layout engine.\n    /** Whether the current browser is Safari. */\n    SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    constructor() { }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.1.3\", ngImport: i0, type: Platform, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.1.3\", ngImport: i0, type: Platform, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.1.3\", ngImport: i0, type: Platform, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass PlatformModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.1.3\", ngImport: i0, type: PlatformModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"19.1.3\", ngImport: i0, type: PlatformModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"19.1.3\", ngImport: i0, type: PlatformModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.1.3\", ngImport: i0, type: PlatformModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }] });\n\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    let featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => (supportsPassiveEvents = true),\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\n/** The possible ways the browser may handle the horizontal scroll axis in RTL languages. */\nvar RtlScrollAxisType;\n(function (RtlScrollAxisType) {\n    /**\n     * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\n     * all the way right.\n     */\n    RtlScrollAxisType[RtlScrollAxisType[\"NORMAL\"] = 0] = \"NORMAL\";\n    /**\n     * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n     * all the way right.\n     */\n    RtlScrollAxisType[RtlScrollAxisType[\"NEGATED\"] = 1] = \"NEGATED\";\n    /**\n     * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n     * all the way right.\n     */\n    RtlScrollAxisType[RtlScrollAxisType[\"INVERTED\"] = 2] = \"INVERTED\";\n})(RtlScrollAxisType || (RtlScrollAxisType = {}));\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if ('scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return RtlScrollAxisType.NORMAL;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = RtlScrollAxisType.NORMAL;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;\n        }\n        scrollContainer.remove();\n    }\n    return rtlScrollAxisType;\n}\n\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document\n        ? document.activeElement\n        : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\n/** Gets whether the code is currently running in a test environment. */\nfunction _isTestEnvironment() {\n    // We can't use `declare const` because it causes conflicts inside Google with the real typings\n    // for these symbols and we can't read them off the global object, because they don't appear to\n    // be attached there for some runners like Jest.\n    // (see: https://github.com/angular/components/issues/23365#issuecomment-938146643)\n    return (\n    // @ts-ignore\n    (typeof __karma__ !== 'undefined' && !!__karma__) ||\n        // @ts-ignore\n        (typeof jasmine !== 'undefined' && !!jasmine) ||\n        // @ts-ignore\n        (typeof jest !== 'undefined' && !!jest) ||\n        // @ts-ignore\n        (typeof Mocha !== 'undefined' && !!Mocha));\n}\n\n// TODO(crisbeto): remove this function when making breaking changes for v20.\n/**\n * Binds an event listener with specific options in a backwards-compatible way.\n * This function is necessary, because `Renderer2.listen` only supports listener options\n * after 19.1 and during the v19 period we support any 19.x version.\n * @docs-private\n */\nfunction _bindEventWithOptions(renderer, target, eventName, callback, options) {\n    const major = parseInt(VERSION.major);\n    const minor = parseInt(VERSION.minor);\n    // Event options in `listen` are only supported in 19.1 and beyond.\n    // We also allow 0.0.x, because that indicates a build at HEAD.\n    if (major > 19 || (major === 19 && minor > 0) || (major === 0 && minor === 0)) {\n        return renderer.listen(target, eventName, callback, options);\n    }\n    target.addEventListener(eventName, callback, options);\n    return () => {\n        target.removeEventListener(eventName, callback, options);\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, PlatformModule, RtlScrollAxisType, _bindEventWithOptions, _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _isTestEnvironment, _supportsShadowDom, getRtlScrollAxisType, getSupportedInputTypes, normalizePassiveListenerOptions, supportsPassiveEventListeners, supportsScrollBehavior };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}